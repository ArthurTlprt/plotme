%{

#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <cmath>
#include <vector>
#include <algorithm>
#include <stack>
#include <fstream>
#include <map>


using namespace std;

#include <string>

extern int yylex();
//extern int yyparse();
extern FILE* yyin;
void yyerror(const char* s);

vector<double> values;
vector<int>    postfixee;

std::string debug_file("debug");
ofstream debug(debug_file.c_str());
double xinf=0;
double xsup=20;
map<string,string> dessine;
%}

%error-verbose

%union {
	int ival;
	float fval;
	char* sval;
}

%token<fval> FLOAT
%token<sval> COLOR VARIABLE
%token PLUS MINUS MULTIPLY DIVIDE LEFT RIGHT EQUAL
%token NEWLINE QUIT
%token  X
%token MPI EXP SIN COS TAN ARCTAN ARCSIN ARCOS SQRT DRAW BRACKETR BRACKETL COMA
%left PLUS MINUS
%left MULTIPLY DIVIDE
%left RIGHT LEFT
%left EXP SIN COS TAN ARCTAN ARCSIN ARCOS SQRT

%type<fval> mixed_expression

%start calculation

%%

calculation:
	   | calculation line
;

line: NEWLINE
		| mixed_expression NEWLINE {}
		| DRAW VARIABLE LEFT X RIGHT COLOR { string a1= $2; string a2=$6; dessine.insert(pair<string,string>(a1,a2)); }
    | QUIT NEWLINE { printf("bye!\n"); exit(0); }
		| VARIABLE LEFT X RIGHT EQUAL mixed_expression {}
		| VARIABLE EQUAL mixed_expression { }
;


mixed_expression: MPI { postfixee.push_back(FLOAT); values.push_back(M_PI); }
		| X EQUAL BRACKETL FLOAT COMA FLOAT BRACKETR {xinf=$4; xsup=$6;}
		| mixed_expression PLUS mixed_expression	 { postfixee.push_back(PLUS); values.push_back(0); }
	  | mixed_expression MINUS mixed_expression	 { postfixee.push_back(MINUS); values.push_back(0);}
	  | mixed_expression MULTIPLY mixed_expression {postfixee.push_back(MULTIPLY); values.push_back(0); }
	  | mixed_expression DIVIDE mixed_expression	 { postfixee.push_back(DIVIDE); values.push_back(0); }
		| LEFT mixed_expression RIGHT		 { }
		| SIN LEFT mixed_expression RIGHT { postfixee.push_back(SIN); values.push_back(0); }
		| COS LEFT mixed_expression RIGHT { postfixee.push_back(COS); values.push_back(0); }
		| TAN LEFT mixed_expression RIGHT { postfixee.push_back(TAN); values.push_back(0); }
		| ARCSIN LEFT mixed_expression RIGHT { postfixee.push_back(ARCSIN); values.push_back(0); }
		| ARCOS LEFT mixed_expression RIGHT { postfixee.push_back(ARCOS); values.push_back(0); }
		| ARCTAN LEFT mixed_expression RIGHT { postfixee.push_back(ARCTAN); values.push_back(0); }
		| EXP LEFT mixed_expression RIGHT { postfixee.push_back(EXP); values.push_back(0); }
		| SQRT LEFT mixed_expression RIGHT { postfixee.push_back(SQRT); values.push_back(0); }
		| X { postfixee.push_back(X); values.push_back(0); }
		| FLOAT                 		 {

		postfixee.push_back(FLOAT);
		values.push_back($1);
		}
;



//constant : FLOAT { $$ = $1; }

%%



double Evaluation(double x){

stack <double> pile;

double a, b;
for (int i = 0; i < postfixee.size(); i++) {
	switch (postfixee[i]) {
		case PLUS :
		     a = pile.top(); pile.pop();
				 b = pile.top(); pile.pop();
				 pile.push(a+b);
		break;
		case FLOAT:
		     pile.push(values[i]);
		break;
		case X :
			pile.push(x);
			break;
		case MULTIPLY:
				a = pile.top(); pile.pop();
				b = pile.top(); pile.pop();
				pile.push(a*b);
		break;
		case MINUS:
				a = pile.top(); pile.pop();
				b = pile.top(); pile.pop();
				pile.push(b-a);
		break;
		case DIVIDE:
			a = pile.top(); pile.pop();
			b = pile.top(); pile.pop();
			pile.push(b/a);
		break;
		case SIN:
			a = pile.top(); pile.pop();
			b=sin(a);
			pile.push(b);
		break;
		case COS:
			a = pile.top(); pile.pop();
			b=cos(a);
			pile.push(b);
		break;
		case TAN:
			a = pile.top(); pile.pop();
			b=tan(a);
			pile.push(b);
		break;
		case EXP:
			a = pile.top(); pile.pop();
			b=exp(a);
			pile.push(b);
		break;
		case SQRT:
			a = pile.top(); pile.pop();
			b=sqrt(a);
			pile.push(b);
		break;
		case ARCSIN:
			a = pile.top(); pile.pop();
			b=asin(a);
			pile.push(b);
		break;
		case ARCOS:
			a = pile.top(); pile.pop();
			b=acos(a);
			pile.push(b);
		break;
		case ARCTAN:
			a = pile.top(); pile.pop();
			b=atan(a);
			pile.push(b);
		break;
	}
}
	return pile.top();
}

int main() {
	yyin = stdin;
	yyparse();
	cout<<dessine.size()<<endl;
  ofstream xStream("x");
	ofstream yStream("y");
	if(dessine.size()>0){
		cout<<"je suis dans l'evaluation"<<endl;
		for (double i = xinf; i < xsup; i+=0.1) {
			xStream << i << " ";
		}
		for (double i = xinf; i < xsup; i+=0.1) {
			yStream << Evaluation(i) << " ";
		}
	}
	return 0;
}

void yyerror(const char* s) {
	fprintf(stderr, "Parse error: %s\n", s);
	exit(1);
}
